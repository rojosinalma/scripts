#!/usr/bin/env python3
"""
Build Tools - GCC Toolchain Builder for Debian 9

A modular Python tool that builds a modern GCC toolchain
for Debian 9 systems without requiring root privileges.

Usage: build-tools [options]

This script orchestrates the building of:
- GNU binutils (assembler, linker, etc.)
- GCC (compiler collection)  
- GNU Make
- GNU Autoconf
- GNU Automake
- GNU Libtool

Each tool is installed in its own isolated directory structure
under LOCAL_PREFIX (default: ~/tools).
"""

import argparse
import sys
from pathlib import Path

# Add the buildtools package to the Python path
sys.path.insert(0, str(Path(__file__).parent))

from buildtools.config import (
    get_versions, get_tool_urls, BUILD_ORDER,
    LOCAL_PREFIX, GNU_MIRROR, MAKE_JOBS, COMPAT_SET, GNU_MIRRORS
)
from buildtools.utils import (
    setup_signal_handlers, create_directories, get_script_directories,
    print_configuration_summary, print_build_summary, print_info, print_error,
    print_success
)
from buildtools.downloader import download_sources, download_specific_source, check_sources_exist
from buildtools.mirror_tester import find_fastest_mirror
from buildtools.builders.binutils import BinutilsBuilder
from buildtools.builders.gcc import GccBuilder
from buildtools.builders.make import MakeBuilder
from buildtools.builders.autotools import AutoconfBuilder, AutomakeBuilder, LibtoolBuilder


# =============================================================================
# BUILDER REGISTRY
# =============================================================================

def get_builder_class(tool_name: str):
    """Get the appropriate builder class for a tool."""
    builders = {
        'binutils': BinutilsBuilder,
        'gcc': GccBuilder,
        'make': MakeBuilder,
        'autoconf': AutoconfBuilder,
        'automake': AutomakeBuilder,
        'libtool': LibtoolBuilder
    }
    return builders.get(tool_name)


def create_builder(tool_name: str, version: str, downloads_dir: Path, 
                  logs_dir: Path, local_prefix: str, make_jobs: int):
    """Create a builder instance for a tool."""
    builder_class = get_builder_class(tool_name)
    if not builder_class:
        raise ValueError(f"Unknown tool: {tool_name}")
    
    return builder_class(tool_name, version, downloads_dir, logs_dir, 
                        local_prefix, make_jobs)


# =============================================================================
# BUILD ORCHESTRATION
# =============================================================================

def build_all_tools(versions, downloads_dir, logs_dir) -> bool:
    """Build all tools in the correct dependency order."""
    print_info(f"Building toolchain with compatibility set: {COMPAT_SET}")
    for tool in BUILD_ORDER:
        print_info(f"  {tool}: {versions[tool]}")
    
    for tool_name in BUILD_ORDER:
        builder = create_builder(tool_name, versions[tool_name], downloads_dir, 
                               logs_dir, LOCAL_PREFIX, MAKE_JOBS)
        
        if not builder.build():
            print_error(f"Failed to build {tool_name}")
            return False
    
    return True


def build_specific_tool(tool_name: str, versions, downloads_dir, logs_dir) -> bool:
    """Build a specific tool."""
    if tool_name not in versions:
        print_error(f"Unknown tool: {tool_name}")
        return False
    
    print_info(f"Building {tool_name} {versions[tool_name]}...")
    
    builder = create_builder(tool_name, versions[tool_name], downloads_dir,
                           logs_dir, LOCAL_PREFIX, MAKE_JOBS)
    
    return builder.build()


def check_build_status(tools, versions, downloads_dir, logs_dir):
    """Check which tools are already built."""
    status = {}
    
    for tool in tools:
        builder = create_builder(tool, versions[tool], downloads_dir,
                               logs_dir, LOCAL_PREFIX, MAKE_JOBS)
        status[tool] = builder.is_built()
    
    return status


# =============================================================================
# MAIN FUNCTION
# =============================================================================

def main():
    """Main entry point."""
    # Set up signal handling
    setup_signal_handlers()
    
    # Parse command line arguments
    parser = argparse.ArgumentParser(
        description="Build GCC toolchain for Debian 9",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                           # Download and build everything
  %(prog)s --only-download           # Download sources only
  %(prog)s --only-build              # Build from existing downloads
  %(prog)s --build-tool gcc          # Build only GCC
  %(prog)s --verbose  # Verbose output
  
Environment Variables:
  LOCAL_PREFIX=/path/to/tools        # Installation directory
  COMPAT_SET=stable                  # Use stable versions
  MAKE_JOBS=8                        # Parallel jobs
        """
    )
    
    parser.add_argument('--only-download', action='store_true',
                        help='Download sources without building')
    parser.add_argument('--only-build', action='store_true',
                        help='Build from existing downloads without downloading')
    parser.add_argument('--verbose', action='store_true',
                        help='Show commands before executing')
    parser.add_argument('--build-tool', choices=BUILD_ORDER,
                        help='Build only a specific tool')
    parser.add_argument('--status', action='store_true',
                        help='Check build status of all tools')
    
    args = parser.parse_args()
    
    # Update global verbose flag if specified
    if args.verbose:
        import buildtools.config
        buildtools.config.VERBOSE = True
    
    # Get script directories
    script_dir = get_script_directories()
    downloads_dir, logs_dir = create_directories(script_dir, LOCAL_PREFIX)
    
    # Get versions and URLs
    versions = get_versions()
    
    # Always test mirrors to find the fastest one
    mirror = find_fastest_mirror(GNU_MIRRORS)
    
    urls = get_tool_urls(versions, mirror)
    
    # Print configuration
    config_info = {
        'Compatibility set': COMPAT_SET,
        'Installation prefix': LOCAL_PREFIX,
        'Downloads directory': downloads_dir,
        'Logs directory': logs_dir,
        'Mirror': mirror,
        'Parallel jobs': MAKE_JOBS
    }
    print_configuration_summary(config_info)
    
    # Handle status check
    if args.status:
        print_info("Checking build status...")
        status = check_build_status(BUILD_ORDER, versions, downloads_dir, logs_dir)
        sources = check_sources_exist(BUILD_ORDER, versions, downloads_dir)
        
        print_info("Build Status:")
        for tool in BUILD_ORDER:
            source_status = "✓" if sources[tool] else "✗"
            build_status = "✓" if status[tool] else "✗"
            print_info(f"  {tool:12} {versions[tool]:8} Source:{source_status} Built:{build_status}")
        return 0
    
    # Download phase
    if not args.only_build:
        if args.build_tool:
            if not download_specific_source(args.build_tool, urls, downloads_dir):
                print_error("Failed to download source")
                return 1
        else:
            if not download_sources(urls, downloads_dir):
                print_error("Failed to download sources")
                return 1
    
    if args.only_download:
        print_success("Download completed")
        return 0
    
    # Build phase
    success = False
    if args.build_tool:
        success = build_specific_tool(args.build_tool, versions, downloads_dir, logs_dir)
    else:
        success = build_all_tools(versions, downloads_dir, logs_dir)
    
    if success:
        tools_to_show = [args.build_tool] if args.build_tool else BUILD_ORDER
        print_build_summary(LOCAL_PREFIX, tools_to_show)
        return 0
    else:
        print_error("Build failed")
        return 1


if __name__ == '__main__':
    sys.exit(main())